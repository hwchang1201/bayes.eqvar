library(mvtnorm)

data_generator_unif <- function(n, p, n_rep, sig, edge_prob, lower_signal){
  # input:
  # n : number of samples
  # p : number of covariates
  # n_rep : number of repeat.
  # sig : the error variance(scalar)
  # edge_prob : edge generating probability of (each) i -> j
  # lower_signal : signal sample from uniform  +- [lower_signal, 1]
  # Note that we can generate dataset with the topological order 1->2-> ...->p

  X = list()
  G = list()
  for(N in 1:n_rep){

    G[[N]] = matrix(0, p, p)
    for(i in 1:p){
      G[[N]][i, ] = c(rep(0,i), rbinom(p-i, 1, edge_prob))
    }

  }

  for(N in 1:n_rep){
    B = matrix(0, p, p)
    n_edge = sum(G[[N]])
    B[G[[N]] == 1] = 2 * runif(n_edge, lower_signal, 1) *  (rbinom(n_edge, 1, 0.5) - 1/2)
    Omega = solve(tcrossprod(diag(p) - B))
    X[[N]] = rmvnorm(n, sigma = sig * Omega)
  }
  # output:
  # G : n_rep length of list, holding true adjacent matrices.
  # X : n_rep length of list, holding data generated by true DAG.
  return(list(G=G, X=X))
}



data_generator_misspecified <- function(n, p, n_rep, sig, edge_prob, lower_signal, eps){
  # input:
  # n : number of samples
  # p : number of covariates
  # n_rep : number of repeat.
  # sig : the error variance(scalar)
  # edge_prob : edge generating probability of (each) i -> j
  # lower_signal : signal sample from uniform  +- [lower_signal, 1]
  # eps : the error variance will be sampled from [sig (1-eps), sig (1+eps)]
  # Note that we can generate dataset with the topological order 1->2-> ...->p

  X = list()
  G = list()
  for(N in 1:n_rep){

    G[[N]] = matrix(0, p, p)
    for(i in 1:p){
      G[[N]][i, ] = c(rep(0,i), rbinom(p-i, 1, edge_prob))
    }

  }

  for(N in 1:n_rep){
    B = matrix(0, p, p)
    n_edge = sum(G[[N]])
    B[G[[N]] == 1] = 2 * runif(n_edge, lower_signal, 1) *  (rbinom(n_edge, 1, 0.5) - 1/2)
    d = runif(p, 1-eps, 1+eps)
    Omega = solve(tcrossprod((diag(p) - B) %*% diag(1/d) , (diag(p) - B)))
    X[[N]] = rmvnorm(n, sigma = sig * Omega)
  }
  # output:
  # G : n_rep length of list, holding true adjacent matrices.
  # X : n_rep length of list, holding data generated by true DAG.
  return(list(G=G, X=X,Omega=Omega))
}

data_generator_gaussian <- function(n, p, n_rep, sig, edge_prob){
  # input:
  # n : number of samples
  # p : number of covariates
  # n_rep : number of repeat.
  # sig : the error variance(scalar)
  # edge_prob : edge generating probability of (each) i -> j
  # Note that we can generate dataset with the topological order 1->2-> ...->p

  X = list()
  G = list()
  for(N in 1:n_rep){

    G[[N]] = matrix(0, p, p)
    for(i in 1:p){
      G[[N]][i, ] = c(rep(0,i), rbinom(p-i, 1, edge_prob))
    }

  }

  for(N in 1:n_rep){
    B = matrix(0, p, p)
    n_edge = sum(G[[N]])
    B[G[[N]] == 1] = rnorm(n_edge)
    Omega = solve(tcrossprod(diag(p) - B))
    X[[N]] = rmvnorm(n, sigma = sig * Omega)
  }
  # output:
  # G : n_rep length of list, holding true adjacent matrices.
  # X : n_rep length of list, holding data generated by true DAG.
  return(list(G=G, X=X,Omega=Omega))
}

data_generator_same <- function(n, p, n_rep, sig, edge_prob, signal){
  # input:
  # n : number of samples
  # p : number of covariates
  # n_rep : number of repeat.
  # sig : the error variance(scalar)
  # edge_prob : edge generating probability of (each) i -> j
  # signal : a constant signal
  # Note that we can generate dataset with the topological order 1->2-> ...->p

  X = list()
  G = list()
  for(N in 1:n_rep){

    G[[N]] = matrix(0, p, p)
    for(i in 1:p){
      G[[N]][i, ] = c(rep(0,i), rbinom(p-i, 1, edge_prob))
    }

  }

  for(N in 1:n_rep){
    B = matrix(0, p, p)
    n_edge = sum(G[[N]])
    B[G[[N]] == 1] = 2 * signal *  (rbinom(n_edge, 1, 0.5) - 1/2)
    Omega = solve(tcrossprod(diag(p) - B))
    X[[N]] = rmvnorm(n, sigma = sig * Omega)
  }
  # output:
  # G : n_rep length of list, holding true adjacent matrices.
  # X : n_rep length of list, holding data generated by true DAG.
  return(list(G=G, X=X))
}


